<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic Tac Toe</title>
    <script src="dummy.js"></script>
  <style>
body, html {  height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction:column; }
        table {  border-collapse: collapse; }
        td {    border: 1px solid black;
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 20px; }

    
        .result {
            margin-top: 50px;
            font-size: 1.5em;
        }
            </style>
</head>
<body>
    <h1>Tic Tac Toe</h1>
    <br>
    <table id="board">

        
    </table>
    <div id="result" class="result"></div>
    <button  class="start-button" onclick="submit()">Go to first page</button>

    <script>

function submit() {
        // Redirect to dummy.html
        window.location.href = 'index.html';
    }
    </script>


    <script>
    let  winner=null;
    let wins = 0;
   
     const matrixSize = localStorage.getItem('matrixSize');
     let board = initializeBoard(parseInt(matrixSize));
// Set the initial turn
let turn = localStorage.getItem('selectedIcon');

        // Function to generate the table based on the selected matrix size
function generateTable() {

for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i); // Get the key at index i
    const value = localStorage.getItem(key); // Get the value corresponding to the key
    console.log(`Key: ${key}, Value: ${value}`); // Log the key-value pair
}
let difficultylevel= localStorage.getItem('difficulty');

//localStorage.removeItem('');

//localStorage.removeItem('matrixSie');

const matrixSize = localStorage.getItem('matrixSize');


// Get the selected matrix size
            const matrixSize1 = parseInt(matrixSize);
            
            // Get the table element
            const table = document.getElementById('board');

            // Clear existing rows from the table
            table.innerHTML = '';

            // Generate rows and cells based on the matrix size
            for (let i = 0; i < matrixSize1; i++) {
                const row = document.createElement('tr');
                for (let j = 0; j < matrixSize1; j++) {
                    const cell = document.createElement('td');
                    cell.setAttribute('onclick', `cellClick(${i * matrixSize + j})`);
                    row.appendChild(cell);
                }
                table.appendChild(row);
            }
        }

        // Generate the table initially
        generateTable();    




function initializeBoard(matrixSize) {
    let board = [];
    const totalCells = matrixSize * matrixSize;
    for (let i = 0; i <= totalCells; i++) {
        board.push(null);
    }
    return board;

}
console.log(board);
//                                                       LET LINES1 =[[]]
 
let lines1= [[]];  
function getlines(a,matrixSize){
    
for (let i = 0; i < matrixSize ; i++) {

    
                                              // let lines= []COMMENT
    let ijk = matrixSize -2;
    for (let j = 0; j < matrixSize ; j++) {
        if (j < ijk) {
            if (isValidIndex(a, i, j) && isValidIndex(a, i, j + 1) && isValidIndex(a, i, j + 2)) {
                lines1.push([a[i][j], a[i][j + 1], a[i][j + 2]]);
            }
        }  

        if (i < ijk) {
            if (isValidIndex(a, i, j) && isValidIndex(a, i + 1, j) && isValidIndex(a, i + 2, j)) {
                lines1.push([a[i][j], a[i + 1][j], a[i + 2][j]]);
            }
        }  
        // for left diagonal
        if (i < ijk && j < ijk) {
            if (isValidIndex(a, i, j) && isValidIndex(a, i + 1, j + 1) && isValidIndex(a, i + 2, j + 2)) {
                lines1.push([a[i][j], a[i + 1][j + 1], a[i + 2][j + 2]]);
            }
        }
     
  //   for right diagonal
   if (i < ijk && j >= 2) {
            if (isValidIndex(a, i, j) && isValidIndex(a, i + 1, j - 1) && isValidIndex(a, i + 2, j - 2)) {
                lines1.push([a[i][j], a[i + 1][j - 1], a[i + 2][j - 2]]);
            }
        }    lines1 = lines1.filter(arr => arr.length > 0);              
      }
}
      
        


return lines1;
  }

function isValidIndex(array, row, col) {
    return row >= 0 && row < array.length && col >= 0 && col < array[row].length;
}


      // Initialize the board array with null values based on the selected matrix size
/* let lines1=[[]];

            for (let i = 0; i < 1 ; i++) {
                let a =[[]];
                let b =[[]];
                let c=[[]];
    for (let j = 0; j < 1 ; j++) {
        if(a[i][j] && b[i+1][j] && c[i+2][j])
                    {
                         lines1.push([a[i][j], a[i+1][j], a[i+2][j]]);

                    }
 if(a[i][j] && b[i][j+1] && c[i][j+2])
                    {
                          lines1.push([a[i][j], a[i][j+1], a[i][j+2]]);

                    }
 if(a[i][j] && b[i][j+1] && c[i][j+2])
{

     lines1.push([a[i][j], a[i+1][j+1], a[i+1][j+2]]);
}}

console.log(lines1);
            }


 /*           for (let i = 0; i < numRows; i++) {
    for (let j = 0; j < numCols; j++) {
        // Access the value at the current indices
        const value = matrixValues[i * numCols + j];
        
        // Check if the current indices match the specified ones
        if ((i === 0 && j === 0) || (i === 0 && j === 1) || (i === 0 && j === 3) ||
            (i === 4 && j === 4)) {
            // Process the value (e.g., print it to the console)
            console.log(`Value at row ${i}, column ${j}: ${value}`);
        }
    }
*/
//let [a, b, c] = lines1[i][j];

                                                             /*let a = [
    [ 0, 1, 2,3,4],
    [ 5,6,7,8,9],
    [10,11,12,13,14],
[15,16,17,18,19],
[20,21,22,23,24],
];                  */
const matrixSize2323 = parseInt(matrixSize);
function generateMatrixWin(matrixSize2323) {
    let matrix = [];
    let count = 0;

    // Create the matrix
    for (let i = 0; i < matrixSize; i++) {
        let row = [];
        for (let j = 0; j < matrixSize; j++) {
            row.push(count);
            count++;
        }
        matrix.push(row);
    }

    return matrix;
}

// Test the function with a matrix size of 5
let resultMatrix = generateMatrixWin(matrixSize);
let a =generateMatrixWin(matrixSize);
// Print the result matrix
for (let i = 0; i < resultMatrix.length; i++) {
   console.log(a[i].join('\t'));
}

/*function isValidCell(array, row, col) {
    // Check if the row index is within bounds
    if (row < 0 || row >= array.length) {
        return false;
    }
    if (array[row][col] == undefined)
    {return false;
    }
    // Check if the column index is within bounds
    if (col < 0 || col >= array[row].length) {
        return false;
    }
    
    // If both row and column indices are within bounds, return true
    return true;
}


for (let i = 0; i < 3; i++) {
  
  for (let j = 0; j < 3; j++) {
     
          if(  j<1)
          {
              lines1.push([a[i][j], a[i][j + 1], a[i][j + 2]]);
          }
          if(  i<1)
          {
            lines1.push([a[i][j], a[i+1][j] , a[i+2][j]]);
           
          }
          //for left digonal
          if(i < 1 && j  <1)
          {lines1.push([a[i][j], a[i+1][j+1] , a[i+2][j+2]]);
          }
          //for right diagonal
          if(i > 2 && j > 2)
          {
          if (isValidIndex(a, i, j) && isValidIndex(a, i + 1, j+1) && isValidIndex(a, i + 2, j+2))
          {
            lines1.push([a[i][j], a[i+2][j+2] , a[i+4][j+4]]);
          }}
          lines1 = lines1.filter(arr => arr.length > 0);

  }
}*/
  



            function checkWinner3() {
         //However, it's important to note that since arrays in JavaScript are reference types,
    // modifying lines or lines1 will affect the other. If you want to make a copy of lines1const lines = [...lines1];
    // const lines = lines1;
   lines=getlines(a,3);
// Iterate through rows
  for (let i = 0; i < lines.length; i++) {
       const [x, y, t] = lines[i];
                if (board[x] && board[x] === board[y] && board[x] === board[t]) {
                    
                        console.log(board[x]);
                    return board[x];
                
                }}
   for (let i = 0; i < 9; i++) {
                if (!board[i]) {
                    return null;
                }
            }    
            
             return 'draw';     
        
        
        }

        function checkWinner57() {
    let result = '';
    
const matrixSize17 = localStorage.getItem('matrixSize');


// Get the selected matrix size
            const matrixSize121 = parseInt(matrixSize17);
    const lines = getlines(a,matrixSize121);
    let winsX = new Set();
    let winsO = new Set();

    // Iterate through each line combination
    for (let i = 0; i < lines.length; i++) {
        const [a, b, c] = lines[i];
        if (board[a] && board[b] && board[c]) {
            // Check if all cells in the line are filled
            if (board[a] === "X" && board[a] === board[b] && board[a] === board[c]) {
                // If all cells have the same value (X or O), add the combination to winsX
                winsX.add([a, b, c].join(','));
                console.log(winsX);
            } else if (board[a] === "O" && board[a] === board[b] && board[a] === board[c]) {
                // If all cells have the same value (X or O), add the combination to winsO
                winsO.add([a, b, c].join(','));
                console.log(winsO);
            }
        }
    }

    // Determine the result
   //// if (winsX.size === 0 && winsO.size === 0) {
    //    result = 'draw';
//    console.log('Drawing');
  //  } 
    //     else {
        result = { winsX: winsX.size, winsO: winsO.size };
        console.log('X Wins:', winsX.size);
        console.log('O Wins:', winsO.size);
 //   }

    console.table(result);
    return result;
}
/*
Unique Combinations: The winsX and winsO sets store unique winning
 combinations encountered during the iteration.
 By using sets, duplicate combinations are automatically eliminated,
  ensuring that each combination is counted only once.

Storing Combinations: When a winning combination is encountered 
(board[a] === board[b] === board[c]), the combination [a, b, c] 
is converted into a string (using join(',')) and added to the respective 
set (winsX or winsO). Since sets only store unique values, duplicate 
combinations are automatically discarded.

Counting Wins: After iterating through all the lines and storing
 the unique winning combinations, we determine the number of wins for "X" 
 and "O" by getting the size of the winsX and winsO sets, respectively. 
 The size of a set represents the number of unique elements it contains, which
  in this case corresponds to the count of unique winning combinations.

Handling Draws: If no winning combinations are found (winsX.size === 0 
&& winsO.size === 0), the game is declared a draw. Otherwise, the number 
of wins for "X" and "O" are logged and returned.  */
/*


            function checkWinner57() {
         //However, it's important to note that since arrays in JavaScript are reference types,
    // modifying lines or lines1 will affect the other. If you want to make a copy of lines1const lines = [...lines1];
    // const lines = lines1;
    let result = '';
   lines=getlines(a);
   let winsX = 0;

   let winsO =0;
// Iterate through rows
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    
    if (board[a] && board[b] && board[c]) {
      
        // Check if all cells in the line are filled
        if (board[a] === "O" && board[a] === board[b] && board[a] === board[c]) {
            // If all cells have the same value (X or O), increment the respective counter
              winsX++;
             console.log('aaa');
              
            } 
            
            else if  (board[a] === "O" && board[a] === board[b] && board[a] === board[c] ) {
            // If all cells have the same value (X or O), increment the respective counter
              winsO++;
              
            
            } 
        }
       
                }  

// Check if the game is a draw
let isDraw = true;
    for (let i = 0; i < board.length; i++) {
        if (!board[i]) {
            isDraw = false;
            break;
        }
    }



      
    if (isDraw && winsX === 0 && winsO === 0) {
        result = 'draw';
        
    console.log('Drawing');
      
    } else {
        result = { winsX, winsO };
        console.log('X Wins:', winsX);
        console.log('O Wins:', winsO);

    }
    console.log(result);
    return result; 
    

                  }      */
   function printBoard() {
            const table = document.getElementById('board');
            const matrixSize2 = parseInt(matrixSize);
           
            const m2322 = matrixSize2 * matrixSize2;
            for (let i = 0; i < m2322; i++) {
                const row = Math.floor(i / matrixSize2 );
                const col = i % matrixSize2 ;
                table.rows[row].cells[col].textContent = board[i];      }  }

/*
                let lines1 = [[]];
                for (let i = 0; i < 3; i++) {
    /* Iterate through columns
    for (let j = 0; j < 3; j++) {
        // Check horizontal winning combinations
        if (j < 1) {
            lines1.push(i * 3 + j);
        }
        
        // Check vertical winning combinations
        if (i <= 1) {
            lines1.push(i * 3 + j);
        }

        // Check diagonal winning combinations
        if (i <= 1 && j <= 1) {
            // Main diagonal
            lines1.push([a[i][j], b[i+1][j+1], c[i+2][j+2]]);
            // Anti-diagonal
            lines1.push([a[i][j+2], b[i+1][j+1], c[i+2][j]]);
        }
    }
}

console.log(lines1);



    function checkin(winner) {
    if (winner === 'draw') {
        console.log('The game ended in a draw!');
    } else {
        // Print the scores
        console.log('X Wins:', winner.winsX);
        console.log('O Wins:', winner.winsO);
     
    }

    // Continue the game
    console.log('Continue playing...');
}
*/
/* Define the sequences of player symbols for 2 players and 3 players
const sequences = {
    2: ['X', 'O'],
    3: ['X', 'O', 'Y']
};
*/
/*
// Get the number of players from somewhere (e.g., localStorage)
let numPlayers = parseInt(localStorage.getItem('numPlayers'));

// Get the selected icon from somewhere (e.g., localStorage)
let selectedIcon = localStorage.getItem('selectedIcon');

// Get the sequence of player symbols based on the number of players
let sequence = sequences[numPlayers];

// If the selected icon is found in the sequence, set it as the starting symbol
if (sequence.includes(selectedIcon)) {
    sequence = sequence.slice(sequence.indexOf(selectedIcon)).concat(sequence.slice(0, sequence.indexOf(selectedIcon)));
}

// Toggle between player symbols
let currentPlayerIndex = 0; // Start with the first player in the sequence

// Toggle to the next player
currentPlayerIndex = (currentPlayerIndex + 1) % sequence.length;

// Get the symbol of the next player
let nextPlayerSymbol = sequence[currentPlayerIndex];

Store the symbol of the next player for the next turn
We define an object sequences to store the sequences of player symbols for 2 players and 3 players.
We retrieve the number of players and the selected icon from localStorage.
Based on the number of players, we select the corresponding sequence of player symbols.
If the selected icon is found in the sequence, we rearrange the sequence so that the 
selected icon becomes the starting symbol.
We toggle between player symbols by incrementing the index and using the modulo operator to 
wrap around if necessary.
We get the symbol of the next player and store it for the next turn.

localStorage.setItem('currentPlayerSymbol', nextPlayerSymbol);
*/
// let turn = localStorage.getItem('selectedIcon');
    function cellClick(index) {
            if (!winner && !board[index]) {
                board[index] = turn;
                let difficultyLevel = localStorage.getItem('difficulty');

                  if (matrixSize === "3" ) {
                      
                      printBoard();
                      winner= checkWinner3();
                       if (winner) {
                        if (winner === 'draw') {
    document.getElementById('result').textContent = "It's a draw! Thanks for playing.";
            } else {
  document.getElementById('result').textContent = `Congratulations! ${winner} have won! Thanks for playing.`;
  
            }
                }else {
                  
                     // Call computermovedifficult() only when it's the computer's turn
             //     turn = (turn === 'X') ?  'O' : 'X';
               
             if (difficultyLevel === "Beginner") {
                turn = (turn === 'X') ? computermoveeasy() : 'X'; 
} else if (difficultyLevel === "Intermediate") {
    turn = 'O'
            turn = (turn === 'X') ? computermovedifficult() : 'X';
  //  turn = (turn === 'X') ? 'O' : 'X';
  
 

   let bestMove=computermovedifficult();
   const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
   const table = document.getElementById('board');
      const row = Math.floor(bestMove / matrixSize2);
         const col = bestMove % matrixSize2;
      table.rows[row].cells[col].textContent = board[bestMove];


                
      printBoard(); 
 // turn ='O';

  turn = 'X';



}  
   


  }

    
                
                
                }
                  else if (matrixSize === "5" || matrixSize ==="7") {
    printBoard();
    let winner123 = checkWinner57();
    if (winner123 === 'draw') {
        document.getElementById('result').textContent = "It's a draw! Thanks for playing.";
    } else {
       
        let resultMessage = '';


    if (`${winner123.winsX}` > `${winner123.winsO}`) {
        resultMessage += ". X is a strong player";
    } else if (`${winner123.winsX}` <`${winner123.winsO}`) {
        resultMessage += ". O is a strong player";
    }
    else{
        resultMessage += "draw";
    }
    document.getElementById('result').textContent = resultMessage;

    
// Display the result message in HTML table format
const table = document.createElement('table');
table.classList.add('result'); 
const tbody = document.createElement('tbody');
table.classList.add('result-table'); 
const tr = document.createElement('tr');

const td = document.createElement('td');

// Create cells for result message
const td1 = td.cloneNode();
td1.textContent = "X Wins";
const td2 = td.cloneNode();
td2.textContent = "O Wins";
const td3 = td.cloneNode();
td3.textContent = "Result";

// Create cells for result counts
const td4 = td.cloneNode();
td4.textContent = winner123.winsX;
const td5 = td.cloneNode();
td5.textContent = winner123.winsO;
const td6 = td.cloneNode();
td6.textContent = resultMessage;

// Append cells to row
tr.appendChild(td1);
tr.appendChild(td2);
tr.appendChild(td3);
tbody.appendChild(tr);

// Create a new row for counts
const trCounts = document.createElement('tr');
trCounts.appendChild(td4);
trCounts.appendChild(td5);
trCounts.appendChild(td6);
tbody.appendChild(trCounts);

// Append tbody to table
table.appendChild(tbody);

// Append table to result element
const resultElement = document.getElementById('result');
resultElement.innerHTML = ''; // Clear previous content
resultElement.appendChild(table);
if (difficultyLevel === "Beginner") {
    turn = (turn === 'X') ? computermoveeasy() : 'X'; 
} else if (difficultyLevel === "Intermediate") {
    turn = 'O'
            turn = (turn === 'X') ? computermovedifficult() : 'X';
  //  turn = (turn === 'X') ? 'O' : 'X';
  
 

   let bestMove=computermovedifficult();
   const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
   const table = document.getElementById('board');
      const row = Math.floor(bestMove / matrixSize2);
         const col = bestMove % matrixSize2;
      table.rows[row].cells[col].textContent = board[bestMove];


                
      printBoard(); 
 // turn ='O';

  turn = 'X';
} 

    // Toggle the turn between 'X' and 'O'
    
}         

            } 
        }}
     //   }

       function computermoveeasy() {
    const table = document.getElementById('board');
    do {
        index = Math.floor(Math.random() * board.length);
    } while (board[index] !== null);
    board[index] = 'O'; // Place the computer's move at the randomly generated index
    
    const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const m78 = matrixSize2 * matrixSize2;
    
    for (let i = 0; i <= m78; i++) {
        const row = Math.floor(i / matrixSize2);
        const col = i % matrixSize2;
      
        table.rows[row].cells[col].textContent = board[i];
    }
   
    turn = 'X';

    lines=getlines(a);
// Iterate through rows
  for (let i = 0; i < lines.length; i++) {
       const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    
                        console.log("WINS"+board[a]);
                        document.getElementById('result').textContent = `Congratulations! ${board[a]} have won! Thanks for playing.`;
                        return board[a];
                
                }}}

   /*         

       function computermovedifficult1() {
    let bestScore = -Infinity;
    let bestMove = null;
   
    const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
     let boardf =[...board];
     console.log(boardf);
    for (let index = 0; index < totalCells; index++) {
        const row = Math.floor(index / matrixSize2);
        const col = index % matrixSize2;
         do{
            boardf[index] = 'O';
            let score = minimax(boardf, 0, false);
            boardf[index] = ""; // Undo the move
            console.log(`Move: ${index}, Score: ${score}`); 
            if (score > bestScore) {
                bestScore = score;
            //    bestMove ={row , column};
                bestMove = index;
            }}while(boardf[index] === null );
        
    }
    //    board[bestMove.row][bestMove.col] = 'O';
    
    
    board[bestMove] = 'O'; // Update the board with the best move
    console.log('Best Move:', bestMove); // Log the best move for debugging
    console.log('Best Score:', bestScore); // Log the best score for debugging
    console.log('Updated Board:', board); // Log the updated board array for debugging
    turn = 'X'; // Assuming 'turn' is a global variable used to track whose turn it is
}
*/


function COMPUTERY()
{
    if(turn === 'O')
{
   let bestMove=computermovedifficult();
   const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
   const table = document.getElementById('board');
      const row = Math.floor(bestMove / matrixSize2);
         const col = bestMove % matrixSize2;
      table.rows[row].cells[col].textContent = board[bestMove];


                
  printBoard(); 
 

//  turn = 'X';
                }


}
function computerMove() {
    // Call your function for computer's move here (e.g., computermovedifficult())
    computermovedifficult();

    // Update the board display after the computer's move
    printBoard();

    // Check for a winner after the computer's move
    winner = checkWinner3();
    if (winner) {
        if (winner === 'draw') {
            document.getElementById('result').textContent = "It's a draw! Thanks for playing.";
        } else {
            document.getElementById('result').textContent = `Congratulations! ${winner} have won! Thanks for playing.`;
        }
    } else {
        // If no winner yet, switch back to the human's turn
        turn = 'X';
    }
}
             

function computermovedifficult() {
             
    let bestScore = -Infinity;
    let bestMove = null;

    const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
   
    for (let index = 0; index < totalCells; index++) {
     //   if (board[index] === null) { 

         if ( board[index] === null || board[index] === '') { 
               board[index] = 'O';
            let score  = minimax(board, 0, false);
        
            board[index] = ''; // Undo the move
            console.log(`Move: ${index}, Score: ${score}`); 
            if (score > bestScore) {
                bestScore = score;
                bestMove = index;
                
            }
        }
    }
    
 
        board[bestMove] = 'O'; // Update the board with the best move
 turn ='X';
return bestMove;
}
    /* do{
            
        }
         while(board[bestMove] === 'O') ;


        console.log('Best Move:', bestMove); // Log the best move for debugging
        console.log('Best Score:', bestScore); // Log the best score for debugging
        console.log('Updated Board:', board); // Log the updated board array for debugging
       
}


*/
        // Update the table display
    /*  printBoard(); // Update the board display after the AI's move
     for (let i = 0; i < totalCells; i++) {
            const row = Math.floor(i / matrixSize2);
            const col = i % matrixSize2;
            table.rows[row].cells[col].textContent = board[i];
        }   
*/
        // Check for a winner after the computer's move and handle game-ending conditions accordingly
   /*     const winner = checkWinner3();
        if (winner) {
            document.getElementById('result').textContent = `Congratulations! ${winner} have won! Thanks for playing.`;
            return;
        }
 else {
        console.log("No valid moves found for computer.");
    }*/



/*

function computermovedifficultylevel1000000000000000000000000000000000000() {
    let bestScore = -Infinity;
    let bestMove = null;
   
    const table = document.getElementById('board');
    const matrixSize = localStorage.getItem('matrixSize');
    const matrixSize2 = parseInt(matrixSize);
    const totalCells = matrixSize2 * matrixSize2;
   
    for (let index = 0; index < totalCells; index++) {
     if (board[index] === "") { 
 //   do {
            board[index] = 'O';
            let score = minimax(board, 0, false);
            board[index] = '';
            console.log(`Move: ${index}, Score: ${score}`); 
            if (score > bestScore) {
                bestScore = score;
                bestMove = index;
       
     }
    }
  //    while (board[index] !== null);
        }
     


    console.log('Best Move:', bestMove); // Log the best move for debuggingHHHH
    console.log('Best Score:', bestScore); // Log the best score for debugging
   
    
   
  board[bestMove] = 'O';
  
      

    console.log('Updated Board:', board); // Log the updated board array for debugging

    // Update the table display
    
   
    printBoard(); // Update the board display after the AI's move
    for (let i = 0; i < totalCells; i++) {
        const row = Math.floor(i / matrixSize2);
        const col = i % matrixSize2;
        table.rows[row].cells[col].textContent = board[i];
    }
    // Check for a winner after the computer's move and handle game-ending conditions accordingly
     turn ='X';
     lines=getlines(a);
// Iterate through rows

for (let i = 0; i < lines.length; i++) {
       const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    
                        console.log("WINS"+board[a]);
                        document.getElementById('result').textContent = `Congratulations! ${board[a]} have won! Thanks for playing.`;
                        return board[a];
                
                }}
     
            }
           
    */
           
 /*   lines=getlines(a);
// Iterate through rows
  for (let i = 0; i < lines.length; i++) {
       const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    
                        console.log("WINS"+board[a]);
                        document.getElementById('result').textContent = `Congratulations! ${board[a]} have won! Thanks for playing.`;
                        return board[a];
                
                }}  */


             
    

          
               
               
                function minimax(board, depth, isMaximizing) {
    
 const table = document.getElementById('board');  
    const lines678=[
  [0, 1, 2],     // First row
  [3, 4, 5],     // Second row
  [6, 7, 8],     // Third row
  [0, 3, 6],     // First column
  [1, 4, 7],     // Second column
  [2, 5, 8],     // Third column
  [0, 4, 8],     // Main diagonal
  [2, 4, 6],
      // Anti-diagonal
] 



//let result=checkWinner3();
// Iterate through rows
let result ='null';

for (let i = 0; i < lines678.length; i++) {
    const [x, t, y] = lines678[i];
    if (board[x] && board[x] === board[y] && board[x] === board[t]) {
        console.log(board[x]);
        result = board[x];
    }
}


    for (let i = 0; i < lines678.length; i++) {
       let [x, y, t] = lines678[i];
                if (board[x] && board[x] === board[y] && board[x] === board[t]) {
                    
                  console.log(board[x]);
                    result= board[x];
                     
                }
           
            }
            if (!board.includes('')) {
        result= 'draw'; // Returns 'draw' if the board is full and there's no winner
    }

  
   

console.log("erwwwwwwwwwwwwwwwwwwwwwwww"+result);
 //  if (result !== null) {
        if (result === 'O') {

            console.log("IN OOOOOOOOOOOOOOO");
            return 10 - depth; // Computer wins
        } else if (result === 'X') {
            return depth - 10; // Human wins
        } else if(result ==='draw') {
            return 0; // Draw
       }
 //   }

    if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < board.length; i++) {
            if (board[i] === '') {
                board[i] = 'O'; // Make a move for the computer
                let score = minimax(board, depth + 1, false);
                board[i] = ''; // Undo the move
                bestScore = Math.max(score, bestScore);
                turn='X';
                console.log("IN AMAXIMIXIN OOOOOOOOOOOOOOO");
            }
        }
        return bestScore;
    } else {
        let bestScore = Infinity;
        for (let i = 0; i < board.length; i++) {
            if (board[i] === '') {
                board[i] = 'X'; // Make a move for the human
                let score = minimax(board, depth + 1, true);
                board[i] = ''; // Undo the move
                bestScore = Math.min(score, bestScore);
               turn ='O';
            }
        }
        return bestScore;
    }
}

               

// Example usage:

// Function to check if a player has won
function minimaxORIGINAL(board, depth,isMaximizing) {
 
    let lines67 = getlines(a);
    let result = null;

    // Check for a winner
    for (let i = 0; i <= board.length; i++) {
        const [a, b, c] = lines67[i];
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            result = board[a];
          
        }
        if (board[a] && board[b] && board[c] && board[a] !== board[b] && board[a] !== board[c]) {
            result = 'draw';
          
        }


    }


    console.log(result);

  //   if (result !== null) {
        // Adjust scores based on the result
        if (result === 'draw') {
            console.log('draw');
           
            return 0;
        } else if (result === 'O') {
           
            return  10 - depth;
        } else if (result === 'X') {
           
            return depth - 10;
        }
 //   }

   if (depth >= 5) {
       return 0; // Return 0 when reaching the maximum depth
     }
     const table = document.getElementById('board');
     
       
    if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
            if (board[i]== '' || board[i]==null) {
                board[i] = 'O';
                let score = minimax(board, depth + 1, false);
                board[i] = '';
                bestScore = Math.max(score, bestScore);
               turn ='X';
                console.log('Best Board in O MINMAX Configuration:', board);
              
          //      
            }
         }
              return bestScore;
    } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
            
            //  ===''
          
          //  this line causes infinite loop 
            if (board[i]== '' || board[i]==null) {
                board[i] = 'X';
                let score = minimax(board, depth + 1, true);
                board[i] = '';
                bestScore = Math.min(score, bestScore);
               turn ='O';
                console.log('Best Board Configuration:  in X ', board); 

            }
            
            
        }
        return bestScore;
    }
}


    </script>
</body>
</html>